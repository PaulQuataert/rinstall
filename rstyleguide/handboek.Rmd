---
title: "Kwaliteitshandboek voor R code"
author: "Thierry Onkelinx en Pieter Verschelde"
date: "Thursday, February 12, 2015"
bibliography: "~/local_tex/bibtex/bib/kwaliteitshandboek.bib"
output: pdf_document
---

# Inleiding

Doel van dit kwaliteitshandboek is het vastleggen van minimumeisen voor R gerelateerde code. Dit is een verplichting in het geval van generieke R projecten die door meerdere mensen worden onderhouden. Het is warm aanbevolen om dit kwaliteitshandboek ook in andere omstandigheden maximaal te volgen.

Het kwaliteitshandboek is gebaseerd op @Boswell2011, @Baath2012, @Baath2013, @Wickham2014 en @Ano2015.

# Naamgeving

Zorg er voor dat de naam reeds een goed beeld geeft van de inhoud. Vermijdt namen zonder betekenis als `tmp`. Probeer namen zo concreet mogelijk te maken. `data` is prima als naam voor een dataset in een generieke functie. `boom` is een betere naam als het gaat over een dataset met gegevens van verschillende bomen. Indien de eenheden van belang zijn, kan je ze best in de naam van de variabelen verwerken. Vergelijk `volume <- function(omtrek, hoogte)` met `werkhout_volume_m3 <- function(omtrek.cm, hoogte.m)`

Maak een goede afweging tussen een lange naam met die veel informatie bevat en een korte naam. Een korte naam is ok als iemand anders de naam ondubbelzinnig kan interpreteren. Vermijdt namen met een ambigue betekenis. Gebruik `TRUE` en `FALSE` steeds voluit. Voor toewijzingen gebruiken we enkel "`<-`". Voor het doorgeven van argumenten aan een functie enkel "`=`".

## Formatering van namen

functie
  ~ underscore separated lowercase
  ~ allemaal kleine letters, underscore "`_`" om woorden te scheiden
  ~ `mean()`, `werkhout_volume_m3()`
object
  ~ point separated lowercase
  ~ allemaal kleine letters, woorden worden door punten gescheiden
  ~ `boom`, `omtrek.cm`
variabele
  ~ upper camelcase
  ~ kolomnamen in matrices en dataframes, namen in lijsten en vectoren
  ~ eerste letter van elk woord in hoofdletters, de rest in kleine letters
  ~ `Aantal`, `SoortNl`, `OmtrekCm`, `HoogteM`
bestandsnaam script met functie
  ~ identiek aan de naam van de (hoofd)functie indien het script de defintie van een functie bevat
  ~ extensie `.R`
overige bestandsnamen
  ~ naam die een beknopte concrete beschrijving van de inhoud

# Lay-out

## Witruimte

In principe scheiden we alles in een regel met één spatie. Uitzonderingen hierop zijn:

haakjes
  ~ geen spaties voor en na een haakje `()`, `[]` of `{}`
komma
  ~ geen spatie voor en één spatie na een komma
`:`, `::` en `:::`
  ~ geen spaties voor en na
leesbaarheid
  ~ extra spaties zijn toegelaten indien ze de leesbaarheid verhogen. Bijvoorbeeld om meerdere regels beter t.o.v. elkaar uit te lijnen.

Lange regels splits je best handmatig over meerdere regels. Hou hierbij logische dingen samen. Een voorbeeld hiervan zijn argumenten van een functie en hun waarde. Laat code die op meerdere regels staat twee spaties inspringen. Je kan RStudio instelling dat een tab automatisch naar twee spaties wordt omgezet (via `Tools`, `Global options`, `Code editing`). Laat code eveneens inspringen binnen elke blok tussen `{` en `}`. Gebruik altijd `{` en `}` ook als het niet strikt noodzakelijk is.

```{r voorbeeld_witruimte, eval = FALSE}
# Goed
lange_functie_naam <- function(
  a = "argument a", b = "waarde b"
){
  samenvoegen <- paste(a, b)
  return(samenvoegen)
}
# slecht
lange_functie_naam =function(a="argument a", b = 
"waarde b")paste(a,b)
```

## Opsplitsen van functionaliteit

We gebruiken geen ellenlange scripts. In plaats daarvan splitsen we de analyse op in zinvolle stappen. Elke stap is gedefinieerd als een afzonderlijke functie en kan op zijn beurt weer uit meerdere subfuncties bestaan. Je moet de volledige werking van een functie in een paar zinnen kunnen uitleggen.  Indien je subfuncties gebruikt, hoeft je bij de uitleg van de hoofdfunctie enkel te verwijzen naar de gebruikte subfuncties zonder de werking van die subfuncties in detail uit te leggen. De uitleg van de werking van een subfunctie staat bij de subfunctie zelf.

Soms bestaat een functie uit verschillende onderdelen bestaat die niet de moeite zijn om als aparte subfuncties uit te werken. In dergelijk geval zet je de verschillende blokken samen in "paragrafen" die gescheiden zijn door een witregel en een regel commentaar.

Gebruik steeds een consistente volgorde van de argumenten van een functie. Gebruik steeds expliciet de naam van de argumenten wanneer het gaat om zelfgedefinieerde functies. In het geval van functies uit de standaard `R` packages hoef je de standaard argumenten niet te benoemen als dat geen negatieve invloed heeft op de leesbaarheid.

```{r, eval = FALSE}
# goed
mean(x = 1:10, na.rm = TRUE)
mean(1:10, na.rm = TRUE)
lm(HoogteM ~ OmtrekCm, data = boom)
lm(formula = HoogteM ~ OmtrekCm, data = boom)
# slecht
mean(na.rm = F, 1:10)
lm(HoogteM ~ OmtrekCm, boom)
lm(data = boom, HoogteM ~ OmtrekCm)
```

# Documentatie

## Generiek

We documenteren de generieke werking van elke functie met behulp van `roxygen`. Alle details staan beschreven in het `Roxygen2` package. De `roxygen` documentatie wordt vlak voor de bijhorende functie geplaatst. Op die manier is het eenvoudig om de documentatie bij te werken van zodra de code gewijzigd wordt.

Volgende onderdelen van de `roxygen` documentatie zijn verplicht voor elke functie:

title
  ~ de titel van de functie. Deze geeft reeds een beknopte indicatie van de werking van de functie.
decription
  ~ de volledige beschrijving van de generieke werking van de functie. Dus wat de functie doet en niet hoe de functie dat doet. Hoe iets exact werkt moet duidelijk worden in de code zelf.
param
  ~ elke argument van de functie wordt beschreven. Wat doet het argument? Welke types zijn toegelaten? Is het verplicht? Wat is de standaardwaarde?
return
  ~ welke output geeft de functie terug?
seealso
  ~ indien de hoofdfunctie gebruikt maakt van subfunctie, verwijs je hiermee naar de relevante subfuncties. Relevante subfuncties zijn de functies die nodig zijn om de globale werking van de hoofdfunctie te begrijpen.
  ~ je kan hier eveneens verwijzingen opnemen naar andere verwachte functies.
examples
  ~ een kort reproduceerbaar voorbeeld van het gebruik van de functie.
  ~ plaats code die lang duurt om uit te voeren of een foutmelding geeft in een `\dontrun{}`.

## Specifiek

Specifieke commentaar slaat op een klein stukje code of een enkele regel code. Gebruik commentaar om een blokje code van een 'titel' te voorzien.

Het is niet nodig om elke regel van commentaar te voorzien. Gebruik liever duidelijke namen voor functies, objecten en variabelen in plaats van onduidelijke namen uit te leggen aan de hand van commentaar. Code die zichzelf voldoende verklaart, hoeft geen verdere commentaar.

Het is nuttige om in de code informatie op te nemen over het waarom je een probleem op die manier opgelost hebt. Of wat de nadelen en randvoorwaarden van die oplossing zijn. 


# R Package

Een R package is een handige manier om functionaliteit te bundellen en te documenten. Dit hoeft niet noodzakelijk beperkt te blijven tot een set van functies waarmee een gebruiker aan de slag kan. Je kan het even goed gebruiken om een volledige analyse, inclusief rapport, te bewaren en te documenteren [Flight2014].

We verwijzen naar @Wickham2015 als een goede handleiding om een R package te bouwen. We beperken ons hier tot het vastleggen van een aantal keuzes.

## Gebruik van functies uit andere packages

We maken maximaal gebruik van functionaliteit uit bestaande packages. Hierbij moeten we er voor waken dat er zo min mogelijk interferentie is tussen packages. Dat doen we door de externe functies die we nodig hebben in een functie te importen in plaats van het externe package te laden met `library()` of `require()`. Dan kan vlot via de `ìmportFrom` tag van `roxygen`.

## Zichtbaar maken van functies

Standaard zijn de functies in een package niet zichtbaar voor de eindgebruikers. We moeten expliciet aangeven welke functies zichtbaar zijn door de functie te exporteren. Dat kan eenvoudig door de `export` tag in de `roxygen` documentatie van de functie op te nemen.

Niet alle functies hoeven noodzakelijk zichtbaar te zijn voor eindgebruikers. Bijvoorbeeld kleine functies die het bepaalde manipulaties iets makkelijker maken. Die functies zijn enkel relevant in het kader van het package zelf. In dergelijke gevallen is het niet nodig om de functie te exporteren.

## Kwaliteitscontrole

De functie `R CMD check` biedt de mogelijkheid om R package op een hele resem onderdelen te testen. De testen omvatten onder andere de controle van syntax, de aanwezigheid van documentatie, de structuur van de metadata, de werkzaamheid van voorbeelden, ... In plaats van een hele reeks gedetailleerde kwaliteitseisen op te stellen is het daarom eenvoudiger om te eisen dat een R package alles tests van `R CMD check --as-cran` moet doorstaan. De enige uitzonderingen hierop zijn:

- `checking CRAN incoming feasibility ... NOTE`
    - `New submission`
    - `Non-FOSS package license`
    - `Suggests or Enhances not in mainstream repositories`
- `checking installed package size ... NOTE`

Als een onderdeel van de kwaliteitscontrole gebruiken we zogenaamde 'unit-tests'. Elke 'unit-test' voert de functie uit met een specifieke set argumenten en vergelijkt de uitkomst met de verwachte uitkomst. Wanneer er geen overeenkomst is, geeft `R CMD check` een fout. De verwachte uitkomst kan allerlei vormen aannemen: een object, de klasse van een object, een waarschuwing, een foutmelding, tekstuele output, ...

'Unit-tests' hebben als grote voordeel dat ze voortdurend testen of de functionaliteit bewaard blijft wanneer code aangepast wordt. Ze verkleinen daardoor de kans dat een aanpassing van de code voor de ene functionaliteit, andere functionaliteit verknoeit (foutmelding of nog veel gevaarlijker: verkeerd resultaat.)

Het schrijven van 'unit-tests' is behoorlijk intensief. Voorbeeld: een bepaald functieargument moet een enkel strikt positief getal zijn. De functie moet een foutmelding geven als het argument:

- niet van de klasse "integer" of "numeric" is
- een lengte heeft verschillend van 1 
- kleiner is dan 1
- niet geheel is

Naast de foutafhandeling in de functie zelf, hebben we voor elk van bovenstaande condities een 'unit-test' nodig. We kunnen de werklast van dergelijke foutafhandeling en bijhorende tests minimaliseren door ze in een generieke functie te zetten. Hieronder eerst het voorbeeld van zo een generieke functie. Vervolgens de bijhorende 'unit-tests' en tenslotte het gebruik in de foutafhandeling van een functie. We kunnen de 'unit-tests' in deze laatste functie beperken omdat deze gerelateerd aan de foutafhandeling van het argument waarde reeds gebeuren door de helper functie. Puriteinen kunnen deze 'unit-tests' als nog opnemen.

```{r testPositief}
# definitie van test_strikt_positief_geheel()
#' Ga na of waarde een enkel strikt positief geheel getal is
#' @param waarde Het te testen object
#' @export
#' @examples
#' test_strikt_positief_geheel(10)
test_strikt_positief_geheel <- function(waarde){
  if(!class(waarde) %in% c("integer", "numeric")){
    stop("waarde moet een getal zijn.")
  }
  if(length(waarde) != 1){
    stop("waarde moet exact een enkel getal zijn.")
  }
  if(waarde <= 0){
    stop("waarde moet strikt positief zijn.")
  }
  if(class(waarde) == "numeric" && abs(waarde - round(waarde)) > 1e-8){
    stop("waarde is niet geheel.")
  }
  return(invisible(TRUE))
}
```

```{r unittest1}
# unit-tests voor test_strikt_positief_geheel()
library(testthat)
# 1L staat voor het integer getal 1
# 1 is het getal 1 als numeric
expect_that(
  test_strikt_positief_geheel(1L),
  is_true()
)
expect_that(
  test_strikt_positief_geheel(1),
  is_true()
)
# geen getal
expect_that(
  test_strikt_positief_geheel("a"),
  throws_error("waarde moet een getal zijn.")
)
# lengte verschillend van 1
expect_that(
  test_strikt_positief_geheel(integer(0)),
  throws_error("waarde moet exact een enkel getal zijn.")
)
expect_that(
  test_strikt_positief_geheel(integer(2)),
  throws_error("waarde moet exact een enkel getal zijn.")
)
# niet strikt positief
expect_that(
  test_strikt_positief_geheel(0L),
  throws_error("waarde moet strikt positief zijn.")
)
expect_that(
  test_strikt_positief_geheel(-0.5),
  throws_error("waarde moet strikt positief zijn.")
)
# niet geheel
expect_that(
  test_strikt_positief_geheel(0.5),
  throws_error("waarde is niet geheel.")
)
```


```{r printPositief}
# definitie van print_strik_positief_geheel()
#' Schrijft een strikt positieve waarde naar het scherm
#' @param waarde
#' @export
#' @examples
#' print_strikt_positief_geheel(10)
print_strikt_positief_geheel <- function(waarde){
  test_strikt_positief_geheel(waarde = waarde)
  cat(waarde)
  return(invisible(NULL))
}
```

```{r unittest2}
# unit-tests voor print_strikt_positief_geheel()
library(testthat)
expect_that(
  print_strikt_positief_geheel(1L),
  prints_text("^1$")
)
```

Bovenstaande voorbeeld omvat relatief eenvoudige 'unit-tests'. Hoe eenvoudiger de functie, hoe makkelijker en beknopter 'unit-tests' te schrijven zijn. Dat is een bijkomend argument om functies te schrijven die slechts één taak uitvoeren. Wanneer we meerdere taken moeten combineren, kunnen we elke taak als een afzonderlijke functie schrijven, documenteren en testen.

Een pragmatische keuze bij het uitwerken van 'unit-tests' is ons in de eerste plaats te beperken tot het testen van eenvoudige situaties zoals de minimum-eisen voor argumenten van een functie, het resultaat van een functie met eerdere eenvoudige functionaliteit, ... Meer complexe problemen pakken we enkel aan wanneer zich een bug in de code voordoet. Stappenplan om een bug aan te pakken:

1. Zoek een MWE (minimal working example) dat de bug repliceert.
1. Maak een 'unit-test' op basis van het MWE, hou hierbij rekening met het gewenste resultaat van de functie. M.a.w. de 'unit-test' falen wanneer toegepast op de huidige code (met de bug).
1. Haal de bug uit de code. De code moet nu voldoen aan de 'unit-test'.

Bovenstaande werkwijze heeft als voordeel dat we steeds de uitzonderingssituaties die in het verleden een bug opleverden steeds opnieuw blijven testen. Op die manier vermijden we dat deze bus in de toekomst terug geïntroduceerd kan worden.

# Documentatie

- Taal
- vignettes

# Versiebeheer

- git
- forks en branches

# Referenties